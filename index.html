<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Scroll-Controlled Animations with Optimized Loading</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      height: 600vh;
      background: #0B0B0B;
      overflow-x: hidden
    }

    .scroll-section {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      overflow: hidden;
      color: #fff;
      text-align: center
    }

    .frame-container {
      position: absolute;
      inset: 0;
      overflow: hidden
    }

    .frame-container img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      position: absolute;
      inset: 0
    }

    .text-content {
      position: relative;
      z-index: 1;
      padding: 20px;
      background: rgba(0, 0, 0, .5);
      border-radius: 10px;
      max-width: 80%
    }

    .text-content h2,
    .text-content p {
      opacity: 0;
      transform: translateY(20px)
    }

    header {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(20, 20, 20, .8);
      padding: 10px 20px;
      z-index: 100;
      display: flex;
      justify-content: space-around
    }

    header a {
      color: #fff;
      text-decoration: none;
      font-weight: bold
    }

    .content-after {
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
      background: #ddd;
      text-align: center
    }

    /* Initial loading indicator for first animation */
    .initial-loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 999;
      color: white;
      transition: opacity 0.5s ease;
    }

    .progress-bar {
      width: 250px;
      height: 10px;
      background: rgba(255, 255, 255, 0.3);
      border-radius: 5px;
      margin-top: 20px;
      overflow: hidden;
    }

    .progress {
      height: 100%;
      background: rgb(49, 49, 49);
      width: 0%;
      border-radius: 5px;
      transition: width 0.3s ease;
    }

    .loading-text {
      margin-top: 10px;
      font-size: 14px;
    }
  </style>
</head>

<body>
  <!-- Initial loading indicator for first animation -->
  <div class="initial-loading" id="initial-loading">
    <h3>Loading First Animation</h3>
    <div class="progress-bar">
      <div class="progress" id="progress"></div>
    </div>
    <div class="loading-text" id="loading-text">0%</div>
  </div>

  <header><a href="#section1">Section 1</a><a href="#section2">Section 2</a><a href="#after">After</a></header>

  <section id="section1" class="scroll-section">
    <div class="frame-container"><img id="frame1" src="video1/0001.jpg" alt=""></div>
    <div class="text-content" id="text1">
      <h2>Welcome to Section 1</h2>
      <p id="text1-p1">Scroll down to see the magic.</p>
      <p id="text1-p2">The frames play as you scroll.</p>
      <p id="text1-p3">Then they pause, but text continues.</p>
      <p id="text1-p4">And finally, the animation resumes.</p>
    </div>
  </section>

  <section id="section2" class="scroll-section">
    <div class="frame-container"><img id="frame2" src="video2/0001.avif" alt=""></div>
    <div class="text-content" id="text2">
      <h2>This is Section 2</h2>
      <p id="text2-p1">A different animation sequence.</p>
      <p id="text2-p2">Controlled entirely by your scroll.</p>
    </div>
  </section>

  <section id="after" class="content-after">
    <h2>Content After Animations</h2>
    <p>Normal scrolling resumes here.</p>
  </section>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollTrigger.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/ScrollToPlugin.min.js"></script>
  <script>
    gsap.registerPlugin(ScrollTrigger, ScrollToPlugin);

    document.addEventListener('DOMContentLoaded', () => {
      // Create frame paths
      const f1 = Array.from({ length: 240 }, (_, i) => `video1/${String(i + 1).padStart(4, '0')}.jpg`);
      const f2 = Array.from({ length: 180 }, (_, i) => `video2/${String(i + 1).padStart(4, '0')}.avif`);

      // Image cache
      const imageCache = new Map();
      const loadingIndicator = document.getElementById('initial-loading');
      const progress = document.getElementById('progress');
      const loadingText = document.getElementById('loading-text');

      // Prevent scrolling during initial load
      document.body.style.overflow = 'hidden';

      // Simple function to load a single image
      function loadImage(src) {
        return new Promise((resolve) => {
          if (imageCache.has(src)) {
            resolve(src);
            return;
          }

          const img = new Image();
          img.onload = () => {
            imageCache.set(src, img);
            resolve(src);
          };
          img.onerror = () => {
            console.warn(`Failed to load: ${src}`);
            resolve(src); // Resolve anyway to not block animation
          };
          img.src = src;
        });
      }

      // helpers to update & finish loading
      function updateProgress(loadedCount, totalFrames) {
        const pct = Math.round(loadedCount / totalFrames * 100);
        progress.style.width = `${pct}%`;
        loadingText.textContent = `${pct}%`;
      }

      function finishFirstLoad(totalFrames) {
        // fade loader
        loadingIndicator.style.opacity = '0';
        setTimeout(() => loadingIndicator.style.display = 'none', 500);
        // now you can scroll
        document.body.style.overflow = '';
        // kick off background for section 2
        preloadSecondAnimation();
      }

      async function preloadFirstAnimation() {
        const totalFrames = f1.length;
        let loadedCount = 0;

        // prevent scrolling until we get enough frames to start
        document.body.style.overflow = 'hidden';

        // fire all loads in parallel
        f1.forEach(src => {
          loadImage(src).then(() => {
            loadedCount++;
            updateProgress(loadedCount, totalFrames);

            // once we have 60 frames, start the animations
            if (loadedCount === 60 && !window.animationsInitialized) {
              initAnimations();
              window.animationsInitialized = true;
            }

            // when every single one is done, finish up
            if (loadedCount === totalFrames) {
              finishFirstLoad(totalFrames);
            }
          });
        });
      }


      // Background loading for second animation
      async function preloadSecondAnimation() {
        // Load the second animation in batches
        const batchSize = 20;

        for (let i = 0; i < f2.length; i += batchSize) {
          const end = Math.min(i + batchSize, f2.length);
          const loadPromises = [];

          for (let j = i; j < end; j++) {
            loadPromises.push(loadImage(f2[j]));
          }

          // Give the browser some breathing room between batches
          await Promise.all(loadPromises);
          await new Promise(resolve => setTimeout(resolve, 100));
        }
      }

      function initAnimations() {
        // Now allow scrolling
        document.body.style.overflow = '';

        const img1 = document.getElementById('frame1');
        const img2 = document.getElementById('frame2');

        // First animation - will be smooth because we've preloaded everything
        const obj1 = { frame: 0 };
        const tl1 = gsap.timeline({
          scrollTrigger: {
            trigger: "#section1",
            start: "top top",
            end: "+=250%",
            scrub: true,
            pin: true,
            anticipatePin: 1
          }
        });

        tl1.to(obj1, {
          frame: 59,
          duration: 3,
          ease: "none",
          onUpdate: function () {
            const frameIndex = Math.round(obj1.frame);
            if (imageCache.has(f1[frameIndex])) {
              img1.src = f1[frameIndex];
            }
          }
        }, 0);

        tl1.to(obj1, {
          frame: 239,
          duration: 4,
          ease: "none",
          onUpdate: function () {
            const frameIndex = Math.round(obj1.frame);
            if (imageCache.has(f1[frameIndex])) {
              img1.src = f1[frameIndex];
            }
          }
        }, 6);

        tl1.to(["#text1 h2", "#text1-p1"], { opacity: 1, y: 0, stagger: .2, duration: 1 }, 0);
        tl1.to("#text1-p2", { opacity: 1, y: 0, duration: 1 }, 1);
        tl1.to("#text1-p3", { opacity: 1, y: 0, duration: 1 }, 3);
        tl1.to("#text1-p4", { opacity: 1, y: 0, duration: 1 }, 5);
        tl1.to("#text1 .text-content>*", { opacity: 0, y: -20, stagger: .1, duration: 2 }, 8);
        tl1.totalDuration(10);

        // Second animation - uses lazy loading fallback if needed
        const obj2 = { frame: 0 };
        const tl2 = gsap.timeline({
          scrollTrigger: {
            trigger: "#section2",
            start: "top top",
            end: "+=200%",
            scrub: true,
            pin: true,
            anticipatePin: 1,
            onEnter: () => {
              // When entering section 2, ensure we start preloading if not already
              if (!window.section2Loading) {
                preloadSecondAnimation();
                window.section2Loading = true;
              }
            }
          }
        });

        tl2.to(obj2, {
          frame: 179,
          duration: 5,
          ease: "none",
          onUpdate: function () {
            const frameIndex = Math.round(obj2.frame);

            // Try from cache first, otherwise load on demand
            if (imageCache.has(f2[frameIndex])) {
              img2.src = f2[frameIndex];
            } else {
              img2.src = f2[frameIndex];
              loadImage(f2[frameIndex]);

              // Also try to load a few frames ahead
              const preloadIndex = frameIndex + 5;
              if (preloadIndex < f2.length) {
                loadImage(f2[preloadIndex]);
              }
            }
          }
        }, 0);

        tl2.to(["#text2 h2", "#text2-p1"], { opacity: 1, y: 0, stagger: .3, duration: 1 }, .5);
        tl2.to("#text2-p2", { opacity: 1, y: 0, duration: 1 }, 2);
        tl2.to("#text2 .text-content>*", { opacity: 0, y: -20, stagger: .2, duration: 1 }, 4);
        tl2.totalDuration(5);

        // Configure navigation links
        document.querySelectorAll('header a[href^="#"]').forEach(a => {
          a.addEventListener('click', e => {
            e.preventDefault();
            gsap.to(window, {
              duration: 1,
              scrollTo: { y: a.getAttribute('href'), offsetY: 70 },
              ease: "power2.inOut"
            });
          });
        });

        // Handle window resize
        window.addEventListener('resize', () => ScrollTrigger.refresh());
      }

      // Start loading sequence
      preloadFirstAnimation();
    });
  </script>
</body>

</html>